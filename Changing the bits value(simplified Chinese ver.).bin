;课题名称:交换4位16进制数的高两位和低两位
0011 0000 0000 0000;	.ORIG x3000
1010 000 000011101;	R0读取DATA内存放的地址x3500
0010 001 000011110;	R1读取TIMES内存放的数值x0007
0010 010 000011110;	R2读取CODE内存放的指令xFF00
1001 010 010 111111;	R2先取反变为x00FF
0101 011 011 1 00000;	AND R3,R3,#0,即R3清零
0001 011 000 000 011;	ADD R3,R0,R3,即R3=R0
0101 011 011 000 010;	AND R3,R3,R2,即R3%=100
;ADD1
0001 011 011 000 011;	ADD R3,R3,R3,即R3*=2
0001 001 001 1 00000;	ADD R1,R1,#0,NO OPERATION指向R1
0000 010 000000010;	R1=0时跳转NEXT
0001 001 001 1 11111;	ADD R1,R1,#-1,即R1--
0000 111 111111011;	无条件跳转ADD1
;NEXT
0101 100 100 1 00000;	R4清零
0001 100 000 000 100;	R4=R0
1001 010 010 111111;	R2取反变回xFF00
0101 100 100 000 010;	AND R4,R4,R2,即R4整除100
0000 010 000001010;	若R4=0跳转ADDUP2
0010 101 000001111;	R5读取CODE内存放的指令xFF00
1001 101 101 111111;	R5取反变为x00FF
;ADD2
0001 100 101 000 100;	ADD R4,R5,R4,即R4+=R5
0001 110 100 000 101;	ADD R6,R4,R5
0101 110 010 000 110;	R6整除100
0000 010 000000010;	R6=0时跳转ADDUP1
0101 110 110 000 110;	R6清零
0000 111 111111010;	无条件跳转ADD2
;ADDUP1
0010 111 000001000;	R7读取SUPPLY内存放的数值x0100
0001 100 100 000 111;	R4+=R7
;ADDUP2
0001 100 011 000 100;	R4+=R3
1011 100 000000010;	将R4的内容放入RESULT
1111 0000 00100101;	TRAP x25,即HALT
0011 0101 0000 0000;	DATA 	.FILL x3500
0011 0101 0000 0001;	RESULT	.FILL x3501
0000 0000 0000 0111;	TIMES	.FILL x0007
1111 1111 0000 0000;	CODE	.FILL xFF00
0000 0001 0000 0000;	SUPPLY	.FILL x0100
;大致思路:交换4位16进制数的高两位和低两位,即为交换16位2进制数的高八位和低八位.
;对于高位,要实行除法;对于低位,要实行乘法
;低位的乘法较为简单,即×2八次(×256)实现左移(2进制8位,16进制2位)
;高位的除法难度较大,因为LC-3中没有现成的除法可以使用,也不能像乘法一样用加法的堆叠来实现(也就是说除法不能套用减法)
;这里采用的是不断加x00FF的方式
;可以发现,一旦(减去了低两位的4位16进制数)加x00FF到一定程度,到超过x10000(产生上溢,显示为下一循环)时,此时低两位恰好为原数的高两位(不信的可以随便找一个数试试)
;因此我们在上溢之前(即加到高两位为FF)进行判断(通过减去xFF00再复原的方式),若即将上溢,则再多加一次x00FF得到最终结果
;*处理特殊情况:当原数本身高两位就是FF的情况时,直接取得高两位(所以程序的先后顺序是先判定再加x00FF);当原数高两位为00时,在加x00FF的过程中会出现两次FF开头,也是直接取得(先判定再加)